import { injectable } from "inversify";
import type { WebStandardStreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/webStandardStreamableHttp.js";
import { $inject } from "../container/decorators.js";
import { TYPES } from "../types/index.js";
import type {
  IMCPClientManager,
  ITransportManager,
  ILogger,
  ServerConfig,
  IMCPSessionController,
} from "../types/interfaces.js";
import { MCPGatewayServer } from "../mcp/gateway-server.js";
import type { IToolRegistry } from "../tools/tool-registry.js";
import type { ResourceAggregationService } from "../mcp/resource-aggregation-service.js";
import type { PromptAggregationService } from "../mcp/prompt-aggregation-service.js";

/**
 * Controller that handles MCP session management and request routing.
 *
 * This controller orchestrates the business logic for handling MCP requests:
 * - Session ID extraction and transport management
 * - Client initialization for sessions
 * - Gateway server creation and connection
 * - Request delegation to the appropriate transport
 *
 * Benefits of this extraction:
 * - Separates HTTP concerns from business logic
 * - Easier to test (no need to spin up HTTP server)
 * - Centralizes session management logic
 * - Makes index.ts a clean composition root
 */
@injectable()
export class MCPSessionController implements IMCPSessionController {
  // Track which transports are currently being connected to prevent race conditions
  private connectingTransports =
    new Set<WebStandardStreamableHTTPServerTransport>();
  // Track which transports have been connected (to prevent re-connection)
  private connectedTransports =
    new WeakSet<WebStandardStreamableHTTPServerTransport>();
  // Map of transport -> gateway server instance (one server per transport/session)
  private gatewayServers = new WeakMap<
    WebStandardStreamableHTTPServerTransport,
    MCPGatewayServer
  >();

  constructor(
    @$inject(TYPES.MCPClientManager) private clientPool: IMCPClientManager,
    @$inject(TYPES.TransportManager)
    private transportManager: ITransportManager,
    @$inject(TYPES.ToolRegistry) private toolRegistry: IToolRegistry,
    @$inject(TYPES.ResourceAggregationService)
    private resourceAggregation: ResourceAggregationService,
    @$inject(TYPES.PromptAggregationService)
    private promptAggregation: PromptAggregationService,
    @$inject(TYPES.ServerConfig) private config: ServerConfig,
    @$inject(TYPES.Logger) private logger: ILogger,
  ) {}

  /**
   * Handle an incoming MCP request.
   *
   * This method:
   * 1. Extracts session ID from request headers
   * 2. Gets or creates transport for the session
   * 3. Initializes MCP clients for the session
   * 4. Connects gateway server if this is a new transport
   * 5. Delegates request handling to the transport
   * 6. Returns the Web Standard Response from the transport
   */
  async handleRequest(req: Request): Promise<Response> {
    try {
      const sessionId = req.headers.get("mcp-session-id") ?? undefined;

      // Get or create transport for this request
      const transport = this.transportManager.getOrCreateForRequest(sessionId);

      // Get the session key for client manager
      // IMPORTANT: Use the header sessionId consistently, NOT transport.sessionId
      // transport.sessionId is a UUID generated by the SDK after initialization,
      // but we need to use the client-provided session ID for client pool keying
      const clientSession = sessionId || "default";

      // Initialize clients for this session if needed
      await this.initializeClientsForSession(clientSession);

      // Connect gateway server if this is a new transport
      // Check our tracking set instead of transport.sessionId (which is set asynchronously)
      if (!this.connectedTransports.has(transport)) {
        if (!this.connectingTransports.has(transport)) {
          // Mark as connecting to prevent race conditions
          this.connectingTransports.add(transport);
          try {
            // Connect the server to the transport (sets up handlers, etc.)
            await this.connectGatewayServer(transport, clientSession);
            // Mark as connected so we don't try again
            this.connectedTransports.add(transport);
          } finally {
            // Clean up connecting marker
            this.connectingTransports.delete(transport);
          }
        } else {
          // Wait for the connection to complete
          // Poll until it's no longer in the connecting set
          while (this.connectingTransports.has(transport)) {
            await new Promise((resolve) => setTimeout(resolve, 10));
          }
        }
      }

      // Handle the request through the transport and return the response
      // This includes the initialization request after server.connect()
      return await transport.handleRequest(req);
    } catch (error) {
      this.logger.error(`Error handling MCP request: ${error}`, error as Error);
      throw error;
    }
  }

  /**
   * Initialize all configured MCP clients for a session.
   *
   * This iterates through the server configuration and creates HTTP or stdio
   * clients as needed. Clients are idempotent - if a client already exists
   * for the session, it won't be recreated.
   */
  private async initializeClientsForSession(sessionId: string): Promise<void> {
    for (const [name, clientConfig] of Object.entries(this.config.mcpClients)) {
      if (clientConfig.type === "http") {
        await this.clientPool.addHttpClient(
          name,
          clientConfig.url,
          sessionId,
          clientConfig.headers,
          clientConfig.allowedTools,
        );
      } else if (clientConfig.type === "stdio") {
        await this.clientPool.addStdioClient(
          name,
          clientConfig.command,
          sessionId,
          clientConfig.args,
          clientConfig.env,
          clientConfig.allowedTools,
        );
      } else {
        // This should never happen due to config validation, but handle it for safety
        const unknownConfig = clientConfig as { type: string };
        this.logger.error(
          `Unsupported client type '${unknownConfig.type}' for '${name}'`,
        );
      }
    }
  }

  /**
   * Connect a new gateway server instance to a transport.
   *
   * Each transport gets its own gateway server instance because an MCP server
   * can only be connected to one transport at a time. The gateway servers share
   * the same tool registry and client pool (singletons).
   */
  private async connectGatewayServer(
    transport: WebStandardStreamableHTTPServerTransport,
    sessionId: string,
  ): Promise<void> {
    this.logger.info(
      `Creating new gateway server instance for session ${sessionId}`,
    );

    // Create a new gateway server instance for this transport/session
    const gatewayServer = new MCPGatewayServer(
      this.toolRegistry,
      this.clientPool,
      this.logger,
      this.resourceAggregation,
      this.promptAggregation,
    );

    // Store it in the weak map for this transport
    this.gatewayServers.set(transport, gatewayServer);

    // Connect the gateway server to the transport
    await gatewayServer.getServer().connect(transport);
  }
}
